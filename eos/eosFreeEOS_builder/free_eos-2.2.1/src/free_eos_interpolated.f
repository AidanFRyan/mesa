C*******************************************************************************
C       Start of the header for a fortran source file for a subroutine
C       of the Free_EOS stellar interior equation of state code
C       Copyright (C) 1996, 1998, 2000, 2001, 2004, 2005, 2006 Alan W. Irwin
C
C       $Id: free_eos_interpolated.f 370 2006-11-29 23:57:39Z airwin $
C
C       For the latest version of this source code, please contact
C       Alan W. Irwin
C       Department of Physics and Astronomy
C       University of Victoria,
C       Box 3055
C       Victoria, B.C., Canada
C       V8W 3P6
C       e-mail: irwin@beluga.phys.uvic.ca.
C
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C
C       End of the header for a fortran source file for a subroutine
C       of the Free_EOS stellar interior equation of state code
C*******************************************************************************
      subroutine free_eos_interpolated(iunit, ifsafe,
     &  ifoption, ifmodified, ifion, kif_in, itab,
     &  xabund, atomic_weight, neps_in, ifcno_fixed,
     &  match_variable, tl, 
     &  degeneracy, pressure, density, energy, enthalpy, entropy,
     &  cp, chi_rho, chi_t, gamma1, grada, gamma3m1)
C      Determine EOS quantities by interpolating a table
C      created by the statef_table programme.  For itab = 1 (read from
C      the file opened with iunit) nine quantities
C      are interpolated directly (see below).  The rest are determined from
C      the independent variables (match_variable and tl) and by
C      using known thermodynamic relations.

C      N.B. For other itab values only a subset of the values are tabulated,
C      interpolated and returned as chosen by the user of this programme to
C      minimize the disk space and i/o necessary for the EOS table that is
C      being interpolated.

C      Parameters:
C      iunit is an already opened unit number for an eos
C       table-header ascii file generated by statef_table.  At first call,
C       this routine reads relevant information from that header file
C       including the name of the unformatted direct access EOS file, closes
C       the header file, and opens the unformatted direct access EOS file
C       using this same unit number.
C      ifsafe should be set to .true. if the user wants important safety
C      checks on the consistency of abundances, etc. to be made.  This
C      is the recommended option, but experienced users who know what they
C      are doing may want to try ifsafe = .false. to gain a few per cent
C      improvement in execution speed at the expense of uncertainty about
C      whether this routine is being called correctly.
C      ifoption, ifmodified, ifion are only in argument list to
C        check consistency with those options used to create the
C        interpolated file.
C      kif_in must be -1 for now, but ultimately the plan is to_use_it
C        just as in free_eos.f
C      itab = 1 (all 9 quantities tabulated), and itab = 2 (minimal 3
C      quantities tabulated) are only itab quantities that are implemented
C      at this time.
C      xabund is abundance by weight of most 20 abundant species in
C        the following (Los Alamos opacity) order:
C        H , He, C , N , O , Ne, Na, Mg, Al, Si,
C        P , S , Cl, Ar, Ca, Ti, Cr, Mn, Fe, Ni
C        (xabund is subject to change due to nuclear processing.)
C      atomic_weight is the mean atomic_weight of each element
C        in the same order.
C        (atomic_weight is subject to change due to nuclear processing.)
C      N.B. Only H, and He (and possibly C, N, and O, as well depending
C        on ifcno_fixed) abundances and weights can be changed from
C        the tabulated values, and any violation of this condition
C        results in an error.
C      ifcno_fixed = 1 means no CNO interpolation is done, and simply
C        choose last CNO table to use.  (This option only valid
C        if ifcno_preserve = 0 or 1 for tabulated results.)
C      ifcno_fixed = 0 means_use_CNO interpolation.  (This option only
C        valid if ifcno_preserve > 0.)
C      match_variable ultimately will depend on kif_in (see above), but for
C        now we have kif_in = -1, and match_variable = ln (P - P_rad)
C      degeneracy, pressure, density, energy, enthalpy, and entropy
C        are all 3-vectors, with the second component being the derivative
C        of the first component wrt match_variable (except for the case where
C        kif_in = -1 where the derivative is wrt to ln P), and the third
C        component being the derivative of the first component wrt tl.
C      definitions:
C        degeneracy(1) is EFF degeneracy parameter ln f defined by
C          wf = sqrt(1.d0 + f) = d eta/d fl
C          eta = fl+2.d0*(wf-log(1.d0+wf))
C          where eta is the CG degeneracy parameter.
C        pressure(1) = ln pressure (except for kif=2, ifrad=2).
C        density(1) = ln density.
C        energy(1) = internal energy per unit mass.
C        enthalpy(1) = enthalpy per unit mass = energy(1) + p/rho.
C        entropy(1) = entropy per unit mass.
C      All the following quantities are defined in chapter 9 of CG, and
C      the further relationships are derived from well-known thermodynamic
C      consistency arguments.
C      cp is the specific heat at constant pressue.
C      chi_rho = partial ln P(rho, T)/partial ln rho = 1/Q_p
C        where Q_p = partial ln rho(P,T)/partial ln P
C      chi_T = partial ln P(rho, T)/partial ln T = Q_t/Q_p
C        where Q_t = -partial ln rho(P,T)/partial ln T  = Q defined by CG.
C      gamma1 = partial ln P(rho,entropy)/partial ln rho
C        = chi_rho/(1 - chi_T grada)
C      grada = gamma2-1/gamma2 = partial ln T(P,entropy)/partial ln P
C        = PQ_T/(rho T C_P)
C      gamma3m1 = gamma3-1 = partial ln T(rho,entropy)/partial ln rho
C        = grada*gamma1
      implicit none
      logical ifsafe
      integer iunit,
     &  ifoption, ifmodified, ifion, kif_in, itab,
     &  ifcno_fixed, neps_in
      double precision xabund(neps_in), atomic_weight(neps_in),
     &  match_variable, tl,
     &  degeneracy(3), pressure(3), density(3),
     &  energy(3), enthalpy(3), entropy(3),
     &  cp, chi_rho, chi_t, gamma1, grada, gamma3m1
      integer neps, maxieos, neos,
     &  maxindex_t, maxindex_g, maxindex_x, maxindex_cno,
     &  index_t, index_g, index_x, index_cno,
     &  iffirst, iunit_local,
     &  ifcno_preserve, ncno, nx, ng1, nt1, ng2, nt2, nt,
     &  nvalues, iline,
     &  ifoption_file, ifmodified_file, ifion_file, itab_file,
     &  ieps_start, ieps, iflast,
     &  icno_index, ix_index, ikind, it_index, ig_index,
     &  icno_index_old, ix_index_old, ikind_old,
     &  it_index_old, ig_index_old,
     &  icno, ix, ig, it, ivalues, irec, ieos
      data icno_index_old, ix_index_old, ikind_old,
     &  it_index_old, ig_index_old /5*0/
      parameter (neps = 20)
      parameter (maxieos = 9)
C      4 CNO sets, 4 X, 4 g, 4 T.
      parameter (maxindex_cno = 4)
      parameter (maxindex_x = 4*maxindex_cno)
      parameter (maxindex_g = 4*maxindex_x)
      parameter (maxindex_t = 4*maxindex_g)
      real*4 eos_store4(maxieos)
      double precision lnten, depsh,
     &  glo1, ghi1, gcoeff1, tlo1, thi1, dg1, dt1,
     &  glo2, ghi2, gcoeff2, tlo2, thi2, dg2, dt2,
     &  delta_tl, delta_g, delta_epsh,
     &  depsh4(4), dg4(4), dt4(4),
     &  xabund_file(neps), atomic_weight_file(neps),
     &  x_file, y_file, z_file,
     &  zcno_file, zprime_file, epscno_file, epscno,
     &  eos_version,
     &  pi, clight, planck, cr, echarge, avogadro,
     &  rydberg, h_mass,
     &  boltzmann, c2, stefan_boltzmann, prad_const,
     &  epstab_max, g,
     &  eos_store_t(maxieos, maxindex_t),
     &  eos_store_g(maxieos, maxindex_g),
     &  eos_store_x(maxieos, maxindex_x),
     &  eos_store_cno(maxieos, maxindex_cno),
     &  dummy, eos_result(maxieos),
     &  t, p, rho, qp, qt, tfuzz
      data tfuzz/1.d-5/
      character*200 title, file_name, line
      data iffirst/0/
      integer lnblnk
      save
      if(iffirst.eq.0) then
        iffirst = 1
        iunit_local = iunit
        lnten = log(10.d0)
        read(iunit,'(a)') title
        read(iunit,'(a)') file_name
        read(iunit,*) nx, ifcno_preserve
        if(nx.lt.4) stop 'free_eos_interpolated: bad nx value'
        if (ifcno_preserve.gt.0) then
C        allows up to 4-table CNO interpolation
          ncno = 4
        else
C        allows only assumption of fixed CNO abundance.
          ncno = 1
        endif
        read(iunit,*) glo1, ghi1, ng1, gcoeff1, tlo1, thi1, nt1
        read(iunit,*) glo2, ghi2, ng2, gcoeff2, tlo2, thi2, nt2
        if(ng1.lt.4.or.nt1.lt.4.or.ng1.lt.4.or.ng2.lt.4)
     &    stop 'free_eos_interpolated: bad ng or nt value'
        glo1 = lnten*glo1
        ghi1 = lnten*ghi1
        dg1 = (ghi1-glo1)/dble(ng1-1)
        tlo1 = lnten*tlo1
        thi1 = lnten*thi1
        dt1 = (thi1-tlo1)/dble(nt1-1)
        glo2 = lnten*glo2
        ghi2 = lnten*ghi2
        dg2 = (ghi2-glo2)/dble(ng2-1)
        tlo2 = lnten*tlo2
        thi2 = lnten*thi2
        dt2 = (thi2-tlo2)/dble(nt2-1)
        nvalues = ng1*nt1 + ng2*nt2
C      skip abund_process output
        do iline = 6,23
          read(iunit,'(a)') line
        enddo
        read(iunit,*) xabund_file
        read(iunit,*) x_file, y_file, z_file,
     &    zcno_file, zprime_file
        read(iunit,*) atomic_weight_file
C        last xtab is not equally spaced (see statef_table),
C         but this is calculation of constant other spacings.
C        also note we are interpolating on eps_x = x/weight.
        depsh = 1.d0/(atomic_weight_file(1)*dble(nx-1))
        depsh4(1) = 0.d0
        depsh4(2) = depsh
        depsh4(3) = 2.d0*depsh
        epscno_file =
     &    xabund_file(3)/atomic_weight_file(3) +
     &    xabund_file(4)/atomic_weight_file(4) +
     &    xabund_file(5)/atomic_weight_file(5)
        read(iunit,*) ifoption_file, ifmodified_file, ifion_file,
     &    itab_file
        if(itab_file.eq.1) then
          neos = 9
        elseif(itab_file.eq.2) then
          neos = 3
        else
          stop 'itab_file >= 2 not implemented'
        endif
        read(iunit,'(a)') eos_version
        read(iunit,*) pi, clight, planck, cr, echarge, avogadro,
     &    rydberg, h_mass
        boltzmann = cr/avogadro
        c2 = planck*clight/boltzmann
        stefan_boltzmann = 2.d0*pi*pi*pi*pi*pi/
     &  (15.d0*c2*c2*c2)*clight*boltzmann
        prad_const = 4.d0*stefan_boltzmann/(3.d0*clight)
        close(iunit)
        open(iunit,access='direct', form='unformatted', recl=4*neos,
     &    file=file_name(1:lnblnk(line)))
      else
        if(iunit.ne.iunit_local)
     &    stop 'free_eos_interpolated: unit inconsistency'
      endif
      if(ifsafe) then
C        Important consistency checks to make sure the correct table is
C        found and the specified abundances are consistent with it.
        if(
     &    ifoption.ne.ifoption_file.or.
     &    ifmodified.ne.ifmodified_file.or.
     &    ifion.ne.ifion_file)
     &    stop 'free_eos_interpolated: EOS option inconsistency'
        if(itab.ne.itab_file)
     &    stop 'free_eos_interpolated: itab inconsistency'
        if(ifcno_fixed.eq.1) then
          if(.not.(ifcno_preserve.eq.0.or.ifcno_preserve.eq.1))
     &      stop 'free_eos_interpolated: inconsistent ifcno_fixed'
          ieps_start = 3
        else
          if(.not.ifcno_preserve.gt.0)
     &      stop 'free_eos_interpolated: inconsistent ifcno_fixed'
          ieps_start = 6
        endif
        do ieps = ieps_start, neps
          if(abs(xabund(ieps)-xabund_file(ieps)).gt.
     &        0.5d-15*
     &        (xabund(ieps)+xabund_file(ieps))
     &        ) then
            write(0,*) 'free_eos_interpolated: abundance is '//
     &        'inconsistent for index = ', ieps
            stop
          endif
          if(abs(atomic_weight(ieps)-atomic_weight_file(ieps)).gt.
     &        0.5d-15*
     &        (atomic_weight(ieps)+atomic_weight_file(ieps))
     &        ) then
            write(0,*) 'free_eos_interpolated: weight is '//
     &        'inconsistent for index = ', ieps
            stop
          endif
        enddo
        if(ifcno_preserve.eq.1) then
          epscno =
     &      xabund(3)/atomic_weight(3) +
     &      xabund(4)/atomic_weight(4) +
     &      xabund(5)/atomic_weight(5)
          if(abs(epscno-epscno_file).gt.
     &        0.5d-15*
     &        (epscno+epscno_file)
     &        ) then
            write(0,*) 'free_eos_interpolated: Total CNO abundance '//
     &        'is not conserved which is inconsistent with table'
            stop
          endif
        endif
      endif
C      End of consistency checks.  Now go to work
      iflast = 0
      if (kif_in.ne.-1) then
        stop 'not implemented'
      endif
      do while(iflast.ne.1)
C        find interpolation indices.
        if(ifcno_fixed.eq.1) then
          icno_index = ncno
          epstab_max = (1.d0 - zcno_file - zprime_file)/
     &      atomic_weight_file(1)
        else
          stop 'not implemented yet'
        endif
        ix_index = max(1,min(nx-3,int(xabund(1)/
     &    (atomic_weight(1)*depsh))))
        delta_epsh = xabund(1)/atomic_weight(1) -
     &    (dble(ix_index-1)*depsh)
        if(ix_index.eq.nx-3) then
          depsh4(4) = epstab_max - dble(ix_index-1)*depsh
        else
          depsh4(4) = 3.d0*depsh
        endif
        it_index = max(1,min(nt1-3,int((tl-tlo1)/dt1)))
        if(tl.lt.tlo1.or.tl.gt.thi2)
     &    stop 'free_eos_interpolated: tl out of range'
C        fuzzy limit between two tables to allow tiny extrapolation in
C        usual case where log T = 6 discontinuity is present.  Allow this
C        extrapolation because low T table has more complete physics.
        if(thi1+tfuzz.lt.tlo2)
     &    stop 'free_eos_interpolated: T gap too large'
        g = match_variable - gcoeff1*(tl - 6.d0*lnten)
        if(tl.lt.thi1+tfuzz.and.glo1.le.g.and.g.le.ghi1) then
          ikind = 1
          nt = nt1
          delta_tl = tl - (tlo1 + dble(it_index-1)*dt1)
          ig_index =  max(1,min(ng1-3,int((g-glo1)/dg1)))
          delta_g = g - (glo1 + dble(ig_index-1)*dg1)
          if (ikind.ne.ikind_old) then
            dt4(1) = 0.d0
            dt4(2) = dt1
            dt4(3) = 2.d0*dt1
            dt4(4) = 3.d0*dt1
            dg4(1) = 0.d0
            dg4(2) = dg1
            dg4(3) = 2.d0*dg1
            dg4(4) = 3.d0*dg1
          endif
        elseif(tl.ge.tlo2) then
          it_index = max(1,min(nt2-3,int((tl-tlo2)/dt2)))
          ikind = 2
          nt = nt2
          delta_tl = tl - (tlo2 + dble(it_index-1)*dt2)
          g = match_variable - gcoeff2*(tl - 6.d0*lnten)
          if(g.lt.glo2.or.g.gt.ghi2)
     &      stop 'free_eos_interpolated: g out of range (ikind=2)'
          ig_index =  max(1,min(ng2-3,int((g-glo2)/dg2)))
          delta_g = g - (glo2 + dble(ig_index-1)*dg2)
          if (ikind.ne.ikind_old) then
            dt4(1) = 0.d0
            dt4(2) = dt2
            dt4(3) = 2.d0*dt2
            dt4(4) = 3.d0*dt2
            dg4(1) = 0.d0
            dg4(2) = dg2
            dg4(3) = 2.d0*dg2
            dg4(4) = 3.d0*dg2
          endif
        else
          stop 'free_eos_interpolated: g out of range (ikind=1)'
        endif
        if(
     &      it_index.ne.it_index_old.or.
     &      ig_index.ne.ig_index_old.or.
     &      ikind.ne.ikind_old.or.
     &      ix_index.ne.ix_index_old.or.
     &      icno_index.ne.icno_index_old
     &      ) then
          it_index_old = it_index
          ig_index_old = ig_index
          ikind_old = ikind
          ix_index_old = ix_index
          icno_index_old = icno_index
          index_t = 0
          do icno = icno_index,ncno
C            remaining ranges are all for 4-point Lagrange.
            do ix = ix_index, ix_index+3
              do ig = ig_index, ig_index+3
                do it = it_index, it_index+3
                  ivalues = (ikind-1)*ng1*nt1 + it + nt*(ig-1)
                  irec = ivalues+nvalues*(ix-1 + nx*(icno-icno_index))
C                  write(0,*) 'icno, ix, ig, it, ivalues, irec = ',
C     &              icno, ix, ig, it, ivalues, irec
                  index_t = index_t + 1
                  if(index_t.gt.maxindex_t)
     &              stop 'free_eos_interpolated: logic error'
                  read(iunit,rec=irec) (eos_store4(ieos), ieos = 1,neos)
C                  convert to double precision and store result
                  do ieos = 1, neos
                    eos_store_t(ieos, index_t) = eos_store4(ieos)
                  enddo
                enddo  !it
              enddo  !ig
            enddo  !ix
          enddo  !icno
        endif
        index_t = 1
        index_g = 0
        do icno = icno_index,ncno
          do ix = ix_index, ix_index+3
            do ig = ig_index, ig_index+3
C              lagrange interpolation in tl.
              index_g = index_g + 1
              if(index_g.gt.maxindex_g) stop 'logic error'
              call lagrange4(delta_tl, index_g.eq.1,
     &          dt4, index_g.eq.1,
     &          eos_store_t(1,index_t), neos, maxieos,
     &          eos_store_g(1,index_g), .false., dummy)
              index_t = index_t + 4
            enddo  !ig
          enddo  !ix
        enddo  !icno
        index_g = 1
        index_x = 0
        do icno = icno_index,ncno
          do ix = ix_index, ix_index+3
C            lagrange interpolation in g.
            index_x = index_x + 1
            if(index_x.gt.maxindex_x) stop 'logic error'
            call lagrange4(delta_g, index_x.eq.1,
     &        dg4, index_x.eq.1,
     &        eos_store_g(1,index_g), neos, maxieos,
     &        eos_store_x(1,index_x), .false., dummy)
C            transform to variables that interpolate best in abundance
C            (eps) space for perfect gas law.  This is the so-called
C            additive volume technique which should work perfectly for
C            ideal, non-degenerate gases where no ionization or dissociation
C            is occurring.  Elsewhere, we take our changes.
            if(itab.eq.1) then
C              inverse density = volume is linear in epsilon
              eos_store_x(1,index_x) = exp(-eos_store_x(1,index_x))
C              ln rho P and T derivatives are independent of epsilon.

C              for low degeneracy f/rho proportional to abundance.
C              for high degeneracy f is more complicated function of ne so
C              no simple transformation linearizes it.  For now do the
C              simple thing which is no transformation, i.e.
C              interpolate in lnf and its derivatives as a function of
C              epsilon.

C              internal energy is linear in epsilon so leave as is.

C              entropy is "almost" linear in epsilon (but not completely) so
C              "leave as is" is probably the best you can do.
              
C              grada is independent of epsilon.
            elseif(itab.eq.2) then
C              inverse density = volume is linear in epsilon
              eos_store_x(1,index_x) = exp(-eos_store_x(1,index_x))
C              ln rho P and T derivatives are independent of epsilon.
C              grada is independent of epsilon.
            else
              stop 'free_eos_interpolated.f: itab > 2 not implemented'
            endif
            index_g = index_g + 4
          enddo  !ix
        enddo  !icno
        index_x = 1
        index_cno = 0
        do icno = icno_index,ncno
C          lagrange interpolation in x.
          index_cno = index_cno + 1
          if(index_cno.gt.maxindex_cno) stop 'logic error'
          call lagrange4(delta_epsh, index_cno.eq.1,
     &      depsh4, index_cno.eq.1,
     &      eos_store_x(1,index_x), neos, maxieos,
     &      eos_store_cno(1,index_cno), .false., dummy)
          index_x = index_x + 4
        enddo  !icno
        if(ifcno_fixed.eq.1) then
          do ieos = 1,neos
            eos_result(ieos) = eos_store_cno(ieos,1)
          enddo
        else
          stop 'not implemented'
        endif
        if(kif_in.eq.-1) then
          iflast = 1
        else
          stop 'not implemented'
        endif
      enddo
      if(kif_in.eq.-1) then
        if(itab.eq.1) then
C          See above for abundance interpolation transforms.
          density(1) = -log(eos_result(1))
          density(2) = eos_result(2)
          density(3) = eos_result(3)
          degeneracy(1) = eos_result(4)
          degeneracy(2) = eos_result(5)
          degeneracy(3) = eos_result(6)
          energy(1) = eos_result(7)
          entropy(1) = eos_result(8)
          grada = eos_result(9)
C          additional results derived from thermodynamic relations:
          t = exp(tl)
          p = exp(match_variable) + prad_const*t**4
          rho = exp(density(1))
          qp = density(2)
          qt = -density(3)
          cp = p*qt/(rho*t*grada)
          pressure(1) = log(p)
          pressure(2) = 1.d0
          pressure(3) = 0.d0
          energy(2) = (qp - qt)*p/rho
          energy(3) = cp*t - qt*p/rho
          enthalpy(1) = energy(1) + p/rho
          enthalpy(2) = (1.d0 - qt)*p/rho
          enthalpy(3) = cp*t
          entropy(2) = -qt*(p/(rho*t))
          entropy(3) = cp
          chi_rho = 1.d0/qp
          chi_t = qt/qp
          gamma1 = chi_rho/(1.d0 - chi_T*grada)
          gamma3m1 = grada*gamma1
        elseif(itab.eq.2) then
C          See above for abundance interpolation transforms.
          density(1) = -log(eos_result(1))
          density(3) = eos_result(2)
          grada = eos_result(3)
C          additional results derived from thermodynamic relations:
          t = exp(tl)
          p = exp(match_variable) + prad_const*t**4
          rho = exp(density(1))
          qt = -density(3)
          cp = p*qt/(rho*t*grada)
          pressure(1) = log(p)
          pressure(2) = 1.d0
          pressure(3) = 0.d0
          energy(3) = cp*t - qt*p/rho
          enthalpy(2) = (1.d0 - qt)*p/rho
          enthalpy(3) = cp*t
          entropy(2) = -qt*(p/(rho*t))
          entropy(3) = cp
        else
          stop 'itab.gt.2.not implemented'
        endif
      else
        stop 'kif_in.ne.-1 not implemented'
      endif
      end
      subroutine lagrange4(xarg, ifnewxarg, x, ifnewx,
     &  y, ny, maxny, result, ifpart, dresult)
C      calculate 4-point Lagrange interpolating polynomial evaluated
C        at xarg for ny sets of y values.
C      ifnewxarg is true if this interpolation is for a new xarg or new x.
C      x(4) is the array of 4 independent points,
C      ifnewx is true if this interpolation is for a new x *spacing*.
C      y(ny,4) is the array of ny 4-vectors.
C      result(ny) is the array of results interpolated at xarg.
C      dresult(ny) is the derivative of the interpolating polynomial
C        evaluated at xarg (only calculated if ifpart.eq.1).
      implicit none
      logical*4 ifnewxarg, ifnewx, ifpart
      integer iy, ny, maxny
      real *8 xarg, x(4), y(maxny,4), result(ny), dresult(ny),
     &  xco(4), dxco(4), xcoeff(4)
      save
      if(ifnewxarg) then
        xco(1) = (xarg-x(2))*(xarg-x(3))*(xarg-x(4))
        xco(2) = (xarg-x(1))*(xarg-x(3))*(xarg-x(4))
        xco(3) = (xarg-x(1))*(xarg-x(2))*(xarg-x(4))
        xco(4) = (xarg-x(1))*(xarg-x(2))*(xarg-x(3))
        if(ifpart) then
          dxco(1) =
     &      (xarg-x(3))*(xarg-x(4)) +
     &      (xarg-x(2))*(xarg-x(4)) +
     &      (xarg-x(2))*(xarg-x(3))
          dxco(2) =
     &      (xarg-x(3))*(xarg-x(4)) +
     &      (xarg-x(1))*(xarg-x(4)) +
     &      (xarg-x(1))*(xarg-x(3))
          dxco(3) =
     &      (xarg-x(2))*(xarg-x(4)) +
     &      (xarg-x(1))*(xarg-x(4)) +
     &      (xarg-x(1))*(xarg-x(2))
          dxco(4) =
     &      (xarg-x(2))*(xarg-x(3)) +
     &      (xarg-x(1))*(xarg-x(3)) +
     &      (xarg-x(1))*(xarg-x(2))
        endif
      endif
      if(ifnewx) then
        xcoeff(1) = 1.d0/((x(1)-x(2))*(x(1)-x(3))*(x(1)-x(4)))
        xcoeff(2) = 1.d0/((x(2)-x(1))*(x(2)-x(3))*(x(2)-x(4)))
        xcoeff(3) = 1.d0/((x(3)-x(1))*(x(3)-x(2))*(x(3)-x(4)))
        xcoeff(4) = 1.d0/((x(4)-x(1))*(x(4)-x(2))*(x(4)-x(3)))
      endif
      do iy = 1, ny
        result(iy) =
     &    xcoeff(1)*xco(1)*y(iy,1) +
     &    xcoeff(2)*xco(2)*y(iy,2) +
     &    xcoeff(3)*xco(3)*y(iy,3) +
     &    xcoeff(4)*xco(4)*y(iy,4)
      enddo
      if(ifpart) then
        do iy = 1, ny
          dresult(iy) =
     &      xcoeff(1)*dxco(1)*y(iy,1) +
     &      xcoeff(2)*dxco(2)*y(iy,2) +
     &      xcoeff(3)*dxco(3)*y(iy,3) +
     &      xcoeff(4)*dxco(4)*y(iy,4)
        enddo
      endif
      end
